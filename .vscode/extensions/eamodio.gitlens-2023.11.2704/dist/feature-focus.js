exports.id=521,exports.ids=[521],exports.modules={1629:(e,t,s)=>{s.d(t,{FocusWebviewProvider:()=>F});var r=s(9496),i=s(5255),n=s(8887),o=s(4155),a=s(8834),h=s(5367),l=s(8452),u=s(4092),c=s(4321),d=s(3646),p=s(2674),f=s(4794),m=s(9529),g=s(4241),R=s(4336),y=s(6004),w=s(5116),b=s(7469),_=s(5798);let I=new _.ke("focus/pr/openWorktree"),q=new _.ke("focus/pr/openBranch"),S=new _.ke("focus/pr/switchToBranch"),C=new _.ke("focus/pr/snooze"),k=new _.ke("focus/pr/pin"),v=new _.ke("focus/issue/snooze"),P=new _.ke("focus/issue/pin"),D=new _.jH("focus/didChange",!0);var B=Object.defineProperty,A=Object.getOwnPropertyDescriptor,$=(e,t,s,r)=>{for(var i,n=r>1?void 0:r?A(t,s):t,o=e.length-1;o>=0;o--)(i=e[o])&&(n=(r?i(t,s,n):i(n))||n);return r&&n&&B(t,s,n),n};class F{constructor(e,t){this.container=e,this.host=t,this._disposable=r.Disposable.from(this.container.subscription.onDidChange(this.onSubscriptionChanged,this),this.container.git.onDidChangeRepositories(async()=>{this._etag!==this.container.git.etag&&(null==this._discovering||(this._etag=await this._discovering,this._etag!==this.container.git.etag))&&this.host.refresh(!0)}))}_pullRequests=[];_issues=[];_discovering;_disposable;_etag;_etagSubscription;_repositoryEventsDisposable;_repos;_enrichedItems;dispose(){this._disposable.dispose()}onMessageReceived(e){switch(e.method){case q.method:(0,_.mq)(q,e,e=>this.onOpenBranch(e));break;case S.method:(0,_.mq)(S,e,e=>this.onSwitchBranch(e));break;case I.method:(0,_.mq)(I,e,e=>this.onOpenWorktree(e));break;case C.method:(0,_.mq)(C,e,e=>this.onSnoozePr(e));break;case k.method:(0,_.mq)(k,e,e=>this.onPinPr(e));break;case v.method:(0,_.mq)(v,e,e=>this.onSnoozeIssue(e));break;case P.method:(0,_.mq)(P,e,e=>this.onPinIssue(e))}}async onPinIssue({issue:e,pin:t}){let s=this._issues?.find(t=>t.issue.nodeId===e.nodeId);if(null!=s){if(t)await this.container.focus.unpinItem(t),this._enrichedItems=this._enrichedItems?.filter(e=>e.id!==t),s.enriched=s.enriched?.filter(e=>e.id!==t);else{let e={type:"issue",id:s.issue.nodeId,remote:s.repoAndRemote.remote,url:s.issue.url},t=await this.container.focus.pinItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}async onSnoozeIssue({issue:e,snooze:t}){let s=this._issues?.find(t=>t.issue.nodeId===e.nodeId);if(null!=s){if(t)await this.container.focus.unsnoozeItem(t),this._enrichedItems=this._enrichedItems?.filter(e=>e.id!==t),s.enriched=s.enriched?.filter(e=>e.id!==t);else{let e={type:"issue",id:s.issue.nodeId,remote:s.repoAndRemote.remote,url:s.issue.url},t=await this.container.focus.snoozeItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}async onPinPr({pullRequest:e,pin:t}){let s=this._pullRequests?.find(t=>t.pullRequest.nodeId===e.nodeId);if(null!=s){if(t)await this.container.focus.unpinItem(t),this._enrichedItems=this._enrichedItems?.filter(e=>e.id!==t),s.enriched=s.enriched?.filter(e=>e.id!==t);else{let e={type:"pr",id:s.pullRequest.nodeId,remote:s.repoAndRemote.remote,url:s.pullRequest.url},t=await this.container.focus.pinItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}async onSnoozePr({pullRequest:e,snooze:t}){let s=this._pullRequests?.find(t=>t.pullRequest.nodeId===e.nodeId);if(null!=s){if(t)await this.container.focus.unsnoozeItem(t),this._enrichedItems=this._enrichedItems?.filter(e=>e.id!==t),s.enriched=s.enriched?.filter(e=>e.id!==t);else{let e={type:"pr",id:s.pullRequest.nodeId,remote:s.repoAndRemote.remote,url:s.pullRequest.url},t=await this.container.focus.snoozeItem(e);if(null==t)return;null==this._enrichedItems&&(this._enrichedItems=[]),this._enrichedItems.push(t),null==s.enriched&&(s.enriched=[]),s.enriched.push(t)}this.notifyDidChangeState()}}findSearchedPullRequest(e){return this._pullRequests?.find(t=>t.pullRequest.id===e.id)}async getRemoteBranch(e){let t,s;let i=e.pullRequest,n=e.repoAndRemote,a=n.repo.uri,h=await n.repo.getMainRepository();if(null==h){r.window.showWarningMessage(`Unable to find main repository(${a.toString()}) for PR #${i.id}`);return}let l=i.refs.base.owner,u=r.Uri.parse(i.refs.base.url),d=i.refs.head.branch,p=r.Uri.parse(i.refs.head.url),m=p.toString(),[,g,R]=(0,f.Sk)(m);if([t]=await h.getRemotes({filter:e=>e.matches(g,R)}),null!=t)s=`${t.name}/${d}`,await this.container.git.fetch(h.path,{remote:t.name});else{let e=await r.window.showInformationMessage(`Unable to find a remote for '${m}'. Would you like to add a new remote?`,{modal:!0},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(e?.title!=="Yes")return;let n=i.refs.head.owner;if(await (0,o.IH)(h,n,m,{confirm:!1,fetch:!0,reveal:!1}),[t]=await h.getRemotes({filter:e=>e.url===m}),null==t)return;s=`${t.name}/${d}`;let a=i.refs.base.repo,c=`pr/${u.toString()===p.toString()?d:s}`;this.container.git.setConfig(h.path,`branch.${c}.github-pr-owner-number`,`${l}#${a}#${i.id}`)}return{remote:t,reference:(0,c.xB)(s,h.path,{refType:"branch",name:s,remote:!0})}}async onOpenBranch({pullRequest:e}){let t=this.findSearchedPullRequest(e);if(null==t)return;let s=await this.getRemoteBranch(t);if(null==s){r.window.showErrorMessage(`Unable to find remote branch for '${t.pullRequest.refs?.head.owner}:${t.pullRequest.refs?.head.branch}'`);return}(0,m.P0)(i.Gh.ShowInCommitGraph,{ref:s.reference})}async onSwitchBranch({pullRequest:e}){let t=this.findSearchedPullRequest(e);if(null==t||t.isCurrentBranch)return;if(null!=t.branch)return a.gu(t.branch.repoPath,t.branch);let s=await this.getRemoteBranch(t);if(null==s){r.window.showErrorMessage(`Unable to find remote branch for '${t.pullRequest.refs?.head.owner}:${t.pullRequest.refs?.head.branch}'`);return}return a.gu(s.remote.repoPath,s.reference)}async onOpenWorktree({pullRequest:e}){let t=this.findSearchedPullRequest(e);if(t?.repoAndRemote==null)return;let s=r.Uri.parse(e.refs.base.url),n=t.repoAndRemote.repo.uri;return(0,m.P0)(i.Gh.OpenOrCreateWorktreeForGHPR,{base:{repositoryCloneUrl:{repositoryName:e.refs.base.repo,owner:e.refs.base.owner,url:s}},githubRepository:{rootUri:n},head:{ref:e.refs.head.branch,sha:e.refs.head.sha,repositoryCloneUrl:{repositoryName:e.refs.head.repo,owner:e.refs.head.owner,url:r.Uri.parse(e.refs.head.url)}},item:{number:parseInt(e.id,10)}})}onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(this._etagSubscription=e.etag,this._access=void 0,this.notifyDidChangeState())}_access;async getAccess(e){return(e||null==this._access)&&(this._access=await this.container.git.access(n.x.Focus)),this._access}async getState(e,t){let s=this.host.baseWebviewState;this._etag=this.container.git.etag,this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories.then(e=>(this._discovering=void 0,e)),this._etag=await this._discovering);let r=await this.getAccess(e);if(!0!==r.allowed)return{...s,access:r};let i=(await this.getRichRepos(e)).filter(e=>e.isGitHub),n=i.filter(e=>e.isConnected&&e.isGitHub);if(!(n.length>0))return{...s,access:r,repos:i.map(e=>W(e))};let o=n.map(e=>W(e)),a=Promise.allSettled([this.getMyPullRequests(n,e),this.getMyIssues(n,e),this.getEnrichedItems(e)]);async function h(){let[e,t,i]=await a;return{...s,access:r,repos:o,pullRequests:b.Sb(e)?.map(e=>({pullRequest:u.l1(e.pullRequest),reasons:e.reasons,isCurrentBranch:e.isCurrentBranch??!1,isCurrentWorktree:e.isCurrentWorktree??!1,hasWorktree:e.hasWorktree??!1,hasLocalBranch:e.hasLocalBranch??!1,enriched:M(e,b.Sb(i)),rank:e.rank})),issues:b.Sb(t)?.map(e=>({issue:l.y$(e.issue),reasons:e.reasons,enriched:M(e,b.Sb(i)),rank:e.rank}))}}return t?(queueMicrotask(async()=>{let e=await h();this.host.notify(D,{state:e})}),{...s,access:r,repos:o}):await h()}async includeBootstrap(){return this.getState(!0,!0)}async getRichRepos(e){if(e||null==this._repos){let e=[],t=[];for(let s of this.container.git.openRepositories){let r=await s.getRichRemote();if(null==r||e.findIndex(e=>e.remote===r)>-1)continue;t.push(s.onDidChange(this.onRepositoryChanged,this));let i=this.container.integrations.getByRemote(r);e.push({repo:s,remote:r,isConnected:i?.maybeConnected??await i?.isConnected()??!1,isGitHub:"github"===r.provider.id})}this._repositoryEventsDisposable&&(this._repositoryEventsDisposable.dispose(),this._repositoryEventsDisposable=void 0),this._repositoryEventsDisposable=r.Disposable.from(...t),this._repos=e}return this._repos}onRepositoryChanged(e){e.changed(d.I6.RemoteProviders,d.du.Any)&&this.notifyDidChangeState(!0)}async getMyPullRequests(e,t){let s=(0,y.UH)();if(t||null==this._pullRequests){let t=[],r=new Map,i=new Map;for(let[n,o]of e.map(e=>[e,this.container.integrations.getMyPullRequests(e.remote)])){let e;try{e=await o}catch(e){R.Yd.error(e,s,`Failed to get prs for '${n.remote.url}'`)}if(null!=e)for(let s of e){if(0===s.reasons.length)continue;let e={...s,repoAndRemote:n,isCurrentWorktree:!1,isCurrentBranch:!1,rank:function(e){let t=0;return e.reasons.includes("authored")?t+=1e3:e.reasons.includes("assigned")?t+=900:e.reasons.includes("review-requested")?t+=800:e.reasons.includes("mentioned")&&(t+=700),e.pullRequest.reviewDecision===u.pD.Approved?e.pullRequest.mergeableState===u.Cz.Mergeable?t+=100:e.pullRequest.mergeableState===u.Cz.Conflicting?t+=90:t+=80:e.pullRequest.reviewDecision===u.pD.ChangesRequested&&(t+=70),t}(s)},o=`${e.pullRequest.refs.head.owner}/${e.pullRequest.refs.head.branch}`,a=r.get(e.repoAndRemote.repo);null==a&&(a=new w.X(t=>e.repoAndRemote.repo.getBranches(null!=t?{paging:t}:void 0)),r.set(e.repoAndRemote.repo,a));let l=i.get(e.repoAndRemote.repo);null==l&&(l=await e.repoAndRemote.repo.getWorktrees(),i.set(e.repoAndRemote.repo,l));let c=await (0,p.K)(e.repoAndRemote.repo,e.pullRequest.refs.head.branch,o,l,a);e.hasWorktree=null!=c,e.isCurrentWorktree=c?.opened===!0;let d=await (0,h.eK)(n.repo,o,a);d&&(e.branch=d,e.hasLocalBranch=!0,e.isCurrentBranch=d.current),t.push(e)}}this._pullRequests=t.sort((e,t)=>{let s=e.rank,r=t.rank;return s===r?e.pullRequest.date.getTime()-t.pullRequest.date.getTime():(r??0)-(s??0)})}return this._pullRequests}async getMyIssues(e,t){let s=(0,y.UH)();if(t||null==this._pullRequests){let t=[];for(let[r,i]of e.map(e=>[e,this.container.integrations.getMyIssues(e.remote)])){let e;try{e=await i}catch(e){R.Yd.error(e,s,`Failed to get issues for '${r.remote.url}'`)}if(null!=e)for(let s of e)0!==s.reasons.length&&t.push({...s,repoAndRemote:r,rank:0})}this._issues=t.sort((e,t)=>t.issue.updatedDate.getTime()-e.issue.updatedDate.getTime())}return this._issues}async getEnrichedItems(e){if(e||null==this._enrichedItems){let e=await this.container.focus.get();this._enrichedItems=e}return this._enrichedItems}async notifyDidChangeState(e,t){this.host.notify(D,{state:await this.getState(e,t)})}}function M(e,t){let s;if(null!=t&&0!==t.length&&0!==(s=null!=e.pullRequest?t.filter(t=>t.entityUrl===e.pullRequest.url):t.filter(t=>t.entityUrl===e.issue.url)).length)return e.enriched=s,s.map(e=>({id:e.id,type:e.type}))}function W(e){return{repo:e.repo.path,isGitHub:e.isGitHub,isConnected:e.isConnected}}$([(0,g.fF)({args:!1})],F.prototype,"onPinIssue",1),$([(0,g.fF)({args:!1})],F.prototype,"onSnoozeIssue",1),$([(0,g.fF)({args:!1})],F.prototype,"onPinPr",1),$([(0,g.fF)({args:!1})],F.prototype,"onSnoozePr",1),$([(0,g.fF)({args:!1})],F.prototype,"onOpenBranch",1),$([(0,g.fF)({args:!1})],F.prototype,"onSwitchBranch",1),$([(0,g.fF)({args:!1})],F.prototype,"onOpenWorktree",1),$([(0,g.fF)()],F.prototype,"getAccess",1),$([(0,g.fF)()],F.prototype,"getState",1),$([(0,g.fF)()],F.prototype,"getRichRepos",1),$([(0,g.fF)({args:{0:!1}})],F.prototype,"getMyPullRequests",1),$([(0,g.fF)({args:{0:!1}})],F.prototype,"getMyIssues",1),$([(0,g.fF)()],F.prototype,"getEnrichedItems",1)}};