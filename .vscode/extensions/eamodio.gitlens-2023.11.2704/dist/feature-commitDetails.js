exports.id=10,exports.ids=[10],exports.modules={7387:(t,e,i)=>{i.d(e,{q:()=>s});function s(t){if(null!=t)try{return JSON.parse(JSON.stringify(t,function(t,e){if(e instanceof Date)return e.getTime();if(e instanceof Map||e instanceof Set)return[...e.entries()];if(e instanceof Function||e instanceof Error)return;if(e instanceof RegExp)return e.toString();let i=this[t];return i instanceof Date?i.getTime():e}))}catch(t){throw t}}},9263:(t,e,i)=>{i.d(e,{CommitDetailsWebviewProvider:()=>tt});var s=i(9496),n=i(3139),o=i(5255),a=i(9311),r=i(6897),h=i(9338),c=i(6450),l=i(439),p=i(8452),d=i(4092),m=i(4321),u=i(3646),g=i(9679),f=i(2226),k=i(9529),w=i(5148),_=i(2061),v=i(4241),S=i(9796),C=i(3105),b=i(4336),x=i(6004);class y{constructor(t=10,e){this.maxSize=t,this.comparator=e}stack=[];get count(){return this.stack.length}_position=0;get position(){return this._position}add(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0);let e=null!=this.comparator?this.stack.findIndex(e=>this.comparator(t,e)):this.stack.indexOf(t);-1!==e?this.stack.splice(e,1):this.stack.length===this.maxSize&&this.stack.pop(),this.stack.unshift(t),this._position=0}get(t){if(null!=t){if(t<0||t>=this.stack.length)return;return this.stack[t]}return this.stack.length>0?this.stack[0]:void 0}insert(t){this._position>0&&(this.stack.splice(0,this._position),this._position=0),this.stack.unshift(t),this._position++}navigate(t){if(!(this.stack.length<=1)){if("back"===t){if(this._position>=this.stack.length-1)return;this._position+=1}else{if(this._position<=0)return;this._position-=1}return this.stack[this._position]}}}var D=i(7469),P=i(7387),F=i(5798),T=i(6260),R=i(620);let q=new F.ke("commit/actions"),W=new F.ke("commit/file/actions"),O=new F.ke("commit/file/open"),E=new F.ke("commit/file/openOnRemote"),A=new F.ke("commit/file/compareWorking"),I=new F.ke("commit/file/comparePrevious"),M=new F.ke("commit/file/stage"),L=new F.ke("commit/file/unstage"),B=new F.ke("commit/pickCommit"),N=new F.ke("commit/searchCommit"),G=new F.ke("commit/switchMode"),j=new F.ke("commit/autolinkSettings"),V=new F.ke("commit/explain"),H=new F.ke("commit/pin"),U=new F.ke("commit/navigate"),Y=new F.ke("commit/preferences/update"),$=new F.ke("commit/wip/createPatch"),J=new F.jH("commit/didChange",!0),z=new F.jH("commit/didChange/wip"),Z=new F.jH("commit/didExplain");var K=Object.defineProperty,Q=Object.getOwnPropertyDescriptor,X=(t,e,i,s)=>{for(var n,o=s>1?void 0:s?Q(e,i):e,a=t.length-1;a>=0;a--)(n=t[a])&&(o=(s?n(e,i,o):n(o))||o);return s&&o&&K(e,i,o),o};class tt{constructor(t,e,i){this.container=t,this.host=e,this.options=i,this._context={mode:"commit",navigationStack:{count:0,position:0},pinned:!1,preferences:this.getPreferences(),commit:void 0,richStateLoaded:!1,formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:void 0},this._disposable=w.D.onDidChangeAny(this.onAnyConfigurationChanged,this)}_bootstraping=!0;_context;_pendingContext;_disposable;_pinned=!1;_focused=!1;_commitStack=new y(10,(t,e)=>t.ref===e.ref);dispose(){this._disposable.dispose(),this._lineTrackerDisposable?.dispose(),this._repositorySubscription?.subscription.dispose(),this._selectionTrackerDisposable?.dispose(),this._wipSubscription?.subscription.dispose()}_skipNextRefreshOnVisibilityChange=!1;async onShowing(t,e,...i){let s,n;let[o]=i;if((0,R.W)(o)){let{commit:t}=o.state;t?.repoPath!=null&&t?.sha!=null&&(s=null!=t.stashNumber?{commit:(0,m.xB)(t.sha,t.repoPath,{refType:"stash",name:t.message,number:t.stashNumber})}:{commit:(0,m.xB)(t.sha,t.repoPath,{refType:"revision",message:t.message})})}else s=null!=o&&"object"==typeof o?o:void 0;return null!=s&&(s.preserveFocus&&(null==e?e={preserveFocus:!0}:e.preserveFocus=!0),{commit:n,...s}=s),null!=n&&"wip"===this.mode&&s?.interaction!=="passive"&&this.setMode("commit"),null!=n||this._pinned||(n=this.getBestCommitOrStash()),null==n||this._context.commit?.ref.startsWith(n.ref)||await this.updateCommit(n,{pinned:!1}),(!s?.preserveVisibility||!!this.host.visible)&&(this._skipNextRefreshOnVisibilityChange=!0,!0)}includeBootstrap(){return this._bootstraping=!0,this._context={...this._context,...this._pendingContext},this._pendingContext=void 0,this.getState(this._context)}registerCommands(){return[(0,k.xR)(`${this.host.id}.refresh`,()=>this.host.refresh(!0))]}onFocusChanged(t){this._focused!==t&&(this._focused=t,t&&this.isLineTrackerSuspended&&this.ensureTrackers())}onMessageReceived(t){switch(t.method){case E.method:(0,F.mq)(E,t,t=>void this.openFileOnRemote(t));break;case O.method:(0,F.mq)(O,t,t=>void this.openFile(t));break;case A.method:(0,F.mq)(A,t,t=>void this.openFileComparisonWithWorking(t));break;case I.method:(0,F.mq)(I,t,t=>void this.openFileComparisonWithPrevious(t));break;case W.method:(0,F.mq)(W,t,t=>void this.showFileActions(t));break;case q.method:(0,F.mq)(q,t,t=>{switch(t.action){case"graph":{let t;if(null==(t="wip"===this._context.mode?this._context.wip?.changes!=null?(0,m.xB)(l.CL,this._context.wip.changes.repository.path,{refType:"revision"}):void 0:null!=this._context.commit?(0,m.qj)(this._context.commit):void 0))return;(0,k.P0)("graph"===this.options.attachedTo?o.Gh.ShowInCommitGraphView:o.Gh.ShowInCommitGraph,{ref:t});break}case"more":this.showCommitActions();break;case"scm":(0,k.dO)("workbench.view.scm");break;case"sha":t.alt?this.showCommitPicker():null!=this._context.commit&&(0,k.P0)(o.Gh.CopyShaToClipboard,{sha:this._context.commit.sha})}});break;case B.method:(0,F.mq)(B,t,t=>this.showCommitPicker());break;case N.method:(0,F.mq)(N,t,t=>this.showCommitSearch());break;case G.method:(0,F.mq)(G,t,t=>this.switchMode(t));break;case j.method:(0,F.mq)(j,t,t=>this.showAutolinkSettings());break;case H.method:(0,F.mq)(H,t,t=>this.updatePinned(t.pin??!1,!0));break;case U.method:(0,F.mq)(U,t,t=>this.navigateStack(t.direction));break;case Y.method:(0,F.mq)(Y,t,t=>this.updatePreferences(t));break;case V.method:(0,F.mq)(V,t,()=>this.explainCommit(t.completionId));break;case M.method:(0,F.mq)(M,t,t=>this.stageFile(t));break;case L.method:(0,F.mq)(L,t,t=>this.unstageFile(t));break;case $.method:(0,F.mq)($,t,t=>this.createPatchFromWip(t))}}onRefresh(t){if(!this._pinned){if("wip"===this.mode){let t=this._context.wip?.changes?.repository.uri;this.updateWipState(this.container.git.getBestRepositoryOrFirst(null!=t?s.Uri.parse(t):void 0))}else{let t=this._pendingContext?.commit??this.getBestCommitOrStash();this.updateCommit(t,{immediate:!1})}}}onReloaded(){this.notifyDidChangeState(!0)}onVisibilityChanged(t){if(this.ensureTrackers(),!t)return;let e=this._skipNextRefreshOnVisibilityChange;if(e&&(this._skipNextRefreshOnVisibilityChange=!1),this._bootstraping){if(this._bootstraping=!1,null==this._pendingContext)return;this.updateState()}else e||this.onRefresh(),this.updateState(!0)}onAnyConfigurationChanged(t){(w.D.changed(t,["defaultDateFormat","views.commitDetails.files","views.commitDetails.avatars"])||w.D.changedAny(t,"workbench.tree.renderIndentGuides")||w.D.changedAny(t,"workbench.tree.indent"))&&(this.updatePendingContext({preferences:{...this._context.preferences,...this._pendingContext?.preferences,...this.getPreferences()}}),this.updateState()),null!=this._context.commit&&w.D.changed(t,["views.commitDetails.autolinks","views.commitDetails.pullRequests"])&&(this.updateCommit(this._context.commit,{force:!0}),this.updateState())}getPreferences(){return{autolinksExpanded:this.container.storage.getWorkspace("views:commitDetails:autolinksExpanded")??!0,avatars:w.D.get("views.commitDetails.avatars"),dateFormat:w.D.get("defaultDateFormat")??"MMMM Do, YYYY h:mma",files:w.D.get("views.commitDetails.files"),indentGuides:w.D.getAny("workbench.tree.renderIndentGuides")??"onHover",indent:w.D.getAny("workbench.tree.indent")}}onCommitSelected(t){if(null!=t.data&&("graph"!==this.options.attachedTo||"gitlens.views.graph"===t.source)&&("default"!==this.options.attachedTo||"gitlens.views.graph"!==t.source)){if("wip"===this.mode){t.data.commit.repoPath!==this._context.wip?.changes?.repository.path&&this.updateWipState(this.container.git.getRepository(t.data.commit.repoPath));return}this._pinned&&"passive"===t.data.interaction?(this._commitStack.insert((0,m.qj)(t.data.commit)),this.updateNavigation()):this.host.show(!1,{preserveFocus:t.data.preserveFocus},t.data)}}_lineTrackerDisposable;_selectionTrackerDisposable;ensureTrackers(){if(this._selectionTrackerDisposable?.dispose(),this._selectionTrackerDisposable=void 0,this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0,this.host.visible&&(this._selectionTrackerDisposable=this.container.events.on("commit:selected",this.onCommitSelected,this),!this._pinned&&"graph"!==this.options.attachedTo)){let{lineTracker:t}=this.container;this._lineTrackerDisposable=t.subscribe(this,t.onDidChangeActiveLines(this.onActiveEditorLinesChanged,this))}}get isLineTrackerSuspended(){return"graph"!==this.options.attachedTo&&null==this._lineTrackerDisposable}suspendLineTracker(){setTimeout(()=>{this._lineTrackerDisposable?.dispose(),this._lineTrackerDisposable=void 0},100)}createPatchFromWip(t){if(null==t.changes)return;let e={type:"wip",repository:{name:t.changes.repository.name,path:t.changes.repository.path,uri:t.changes.repository.uri},files:t.changes.files,revision:{to:l.CL,from:"HEAD"},checked:t.checked};(0,g.l)({mode:"create",create:{changes:[e]}})}onActiveEditorLinesChanged(t){if(t.pending||null==t.editor||t.suspended)return;if("wip"===this.mode){let e=this.container.git.getBestRepositoryOrFirst(t.editor);this.updateWipState(e);return}let e=t.selections?.[0]?.active,i=null!=e?this.container.lineTracker.getState(e)?.commit:void 0;this.updateCommit(i)}_wipSubscription;get mode(){return this._pendingContext?.mode??this._context.mode}setMode(t,e){this.updatePendingContext({mode:t}),"commit"===t?(this._wipSubscription?.subscription.dispose(),this._wipSubscription=void 0,this.updateState(!0)):this.updateWipState(e??this.container.git.getBestRepositoryOrFirst())}async explainCommit(t){let e;try{let t=await this.container.ai.explainCommit(this._context.commit,{progress:{location:{viewId:this.host.id}}});if(null==t)throw Error("Error retrieving content");e={summary:t}}catch(t){e={error:{message:t.message}}}this.host.notify(Z,e,t)}navigateStack(t){let e=this._commitStack.navigate(t);null!=e&&this.updateCommit(e,{immediate:!0,skipStack:!0})}_cancellationTokenSource=void 0;async getState(t){let e;if(null!=this._cancellationTokenSource&&(this._cancellationTokenSource.cancel(),this._cancellationTokenSource=void 0),null!=t.commit&&(e=await this.getDetailsModel(t.commit,t.formattedMessage),!t.richStateLoaded)){this._cancellationTokenSource=new s.CancellationTokenSource;let e=this._cancellationTokenSource.token;setTimeout(()=>{e.isCancellationRequested||this.updateRichState(t,e)},100)}return(0,P.q)({...this.host.baseWebviewState,mode:t.mode,commit:e,navigationStack:t.navigationStack,pinned:t.pinned,preferences:t.preferences,includeRichContent:t.richStateLoaded,autolinkedIssues:t.autolinkedIssues?.map(p.Gj),pullRequest:null!=t.pullRequest?(0,d.l1)(t.pullRequest):void 0,wip:t.wip})}async updateWipState(t){let e;if(null!=this._wipSubscription){let{repo:e,subscription:i}=this._wipSubscription;t?.path!==e.path&&(i.dispose(),this._wipSubscription=void 0)}if(null!=t&&(null==this._wipSubscription&&(this._wipSubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)}),e={changes:await this.getWipChange(t),repositoryCount:this.container.git.openRepositoryCount},null==this._pendingContext&&await this.host.notify(z,{wip:e}))){this._context.wip=e;return}this.updatePendingContext({wip:e}),this.updateState(!0)}async updateRichState(t,e){let{commit:i}=t;if(null==i)return;let s=await this.container.git.getBestRemoteWithIntegration(i.repoPath);if(e.isCancellationRequested)return;let[n,o]=s?.provider!=null?await Promise.allSettled([w.D.get("views.commitDetails.autolinks.enabled")&&w.D.get("views.commitDetails.autolinks.enhanced")?(0,f.IN)(i.getEnrichedAutolinks(s)):void 0,w.D.get("views.commitDetails.pullRequests.enabled")?i.getAssociatedPullRequest(s):void 0]):[];if(e.isCancellationRequested)return;let a=D.Sb(n)?.value,r=(0,D.Sb)(o),h=this.getFormattedMessage(i,s,a);this.updatePendingContext({richStateLoaded:!0,formattedMessage:h,autolinkedIssues:null!=a?[...(0,C.DZ)(a.values(),([t])=>t?.value)]:void 0,pullRequest:r}),this.updateState()}_repositorySubscription;async updateCommit(t,e){let i;if(!e?.force&&this._context.commit?.sha===t?.ref)return;if((0,c.f_)(t))i=t;else if(null!=t){if("stash"===t.refType){let e=await this.container.git.getStash(t.repoPath);i=e?.commits.get(t.ref)}else i=await this.container.git.getCommit(t.repoPath,t.ref)}let s=this._pendingContext?.wip??this._context.wip;if(null!=this._repositorySubscription){let{repo:t,subscription:e}=this._repositorySubscription;i?.repoPath!==t.path&&(e.dispose(),this._repositorySubscription=void 0,s=void 0)}if(null==this._repositorySubscription&&null!=i){let t=await this.container.git.getOrOpenRepository(i.repoPath);null!=t&&(this._repositorySubscription={repo:t,subscription:this.subscribeToRepositoryWip(t)},"wip"===this.mode?this.updateWipState(t):s=void 0)}this.updatePendingContext({commit:i,richStateLoaded:!!i?.isUncommitted||!(0,_.fw)("gitlens:hasConnectedRemotes"),formattedMessage:void 0,autolinkedIssues:void 0,pullRequest:void 0,wip:s},e?.force),e?.pinned!=null&&this.updatePinned(e?.pinned),this.isLineTrackerSuspended&&this.ensureTrackers(),null!=i&&(e?.skipStack||this._commitStack.add((0,m.qj)(i)),this.updateNavigation()),this.updateState(e?.immediate??!0)}subscribeToRepositoryWip(t){return s.Disposable.from(t.watchFileSystem(1e3),t.onDidChangeFileSystem(()=>this.onWipChanged(t)),t.onDidChange(e=>{e.changed(u.I6.Index,u.du.Any)&&this.onWipChanged(t)}))}onWipChanged(t){this.updateWipState(t)}async getWipChange(t){let e=await this.container.git.getStatusForRepo(t.path);if(null==e)return;let i=[];for(let t of e.files){let e={repoPath:t.repoPath,path:t.path,status:t.status,originalPath:t.originalPath,staged:t.staged};i.push(e),t.staged&&t.wip&&i.push({...e,staged:!1})}return{repository:{name:t.name,path:t.path,uri:t.uri.toString()},branchName:e.branch,files:i}}updatePinned(t,e){t!==this._context.pinned&&(this._pinned=t,this.ensureTrackers(),this.updatePendingContext({pinned:t}),this.updateState(e))}updatePreferences(t){if(this._context.preferences?.autolinksExpanded===t.autolinksExpanded&&this._context.preferences?.files?.compact===t.files?.compact&&this._context.preferences?.files?.icon===t.files?.icon&&this._context.preferences?.files?.layout===t.files?.layout&&this._context.preferences?.files?.threshold===t.files?.threshold)return;let e={...this._context.preferences,...this._pendingContext?.preferences};null!=t.autolinksExpanded&&this._context.preferences?.autolinksExpanded!==t.autolinksExpanded&&(this.container.storage.storeWorkspace("views:commitDetails:autolinksExpanded",t.autolinksExpanded),e.autolinksExpanded=t.autolinksExpanded),null!=t.files&&(this._context.preferences?.files?.compact!==t.files?.compact&&w.D.updateEffective("views.commitDetails.files.compact",t.files?.compact),this._context.preferences?.files?.icon!==t.files?.icon&&w.D.updateEffective("views.commitDetails.files.icon",t.files?.icon),this._context.preferences?.files?.layout!==t.files?.layout&&w.D.updateEffective("views.commitDetails.files.layout",t.files?.layout),this._context.preferences?.files?.threshold!==t.files?.threshold&&w.D.updateEffective("views.commitDetails.files.threshold",t.files?.threshold),e.files=t.files),this.updatePendingContext({preferences:e}),this.updateState()}updatePendingContext(t,e=!1){let[i,s]=(0,T.OY)(this._context,this._pendingContext,t,e);return i&&(this._pendingContext=s),i}_notifyDidChangeStateDebounced=void 0;updateState(t=!1){if(t){this.notifyDidChangeState();return}null==this._notifyDidChangeStateDebounced&&(this._notifyDidChangeStateDebounced=(0,S.Ds)(this.notifyDidChangeState.bind(this),500)),this._notifyDidChangeStateDebounced()}updateNavigation(){let t=this._commitStack.get(this._commitStack.position-1)?.ref;null!=t&&(t=(0,m.zL)(t)),this.updatePendingContext({navigationStack:{count:this._commitStack.count,position:this._commitStack.position,hint:t}}),this.updateState()}async notifyDidChangeState(t=!1){let e;let i=(0,x.UH)();return this._notifyDidChangeStateDebounced?.cancel(),(!!t||null!=this._pendingContext)&&(null!=this._pendingContext?(e={...this._context,...this._pendingContext},this._context=e,this._pendingContext=void 0):e=this._context,s.window.withProgress({location:{viewId:this.host.id}},async()=>{try{await this.host.notify(J,{state:await this.getState(e)})}catch(t){b.Yd.error(i,t)}}))}getBestCommitOrStash(){let t;if(!this._pinned){if("graph"!==this.options.attachedTo&&null!=s.window.activeTextEditor){let{lineTracker:e}=this.container,i=e.selections?.[0].active;null!=i&&(t=e.getState(i)?.commit)}else if(null==(t=this._pendingContext?.commit)){let e=this.container.events.getCachedEventArgs("commit:selected");t=e?.commit}return t}}async getDetailsModel(t,e){let[i,s,o]=await Promise.allSettled([t.hasFullDetails()?t:t.ensureFullDetails().then(()=>t),t.author.getAvatarUri(t,{size:32}),this.container.git.getBestRemoteWithIntegration(t.repoPath,{includeDisconnected:!0})]);t=(0,D.Sb)(i,t);let a=(0,D.Sb)(s),r=(0,D.Sb)(o);null==e&&(e=this.getFormattedMessage(t,r));let h=null!=t.message?this.container.autolinks.getAutolinks(t.message,r):void 0;return{repoPath:t.repoPath,sha:t.sha,shortSha:t.shortSha,author:{...t.author,avatar:a?.toString(!0)},message:e,parents:t.parents,stashNumber:"stash"===t.refType?t.number:void 0,files:t.files,stats:t.stats,autolinks:null!=h?[...(0,C.UI)(h.values(),n.G)]:void 0}}getFormattedMessage(t,e,i){let s=h.i.fromTemplate("${message}",t),n=s.indexOf("\n");return(-1!==n&&(s=`${s.substring(0,n)}\0
\0${s.substring(n+1)}`),w.D.get("views.commitDetails.autolinks.enabled"))?this.container.autolinks.linkify(s,"html",null!=e?[e]:void 0,i):s}async getFileCommitFromParams(t){let e;if("wip"===this.mode){let t=this._context.wip?.changes?.repository.uri;if(null==t)return;e=await this.container.git.getCommit(s.Uri.parse(t),l.CL)}else e=this._context.commit;return null!=(e=await e?.getCommitForFile(t.path,t.staged))?[e,e.file]:void 0}showAutolinkSettings(){(0,k.P0)(o.Gh.ShowSettingsPageAndJumpToAutolinks)}showCommitPicker(){(0,a.m)({command:"log",state:{reference:"HEAD",repo:this._context.commit?.repoPath,openPickInView:!0}})}showCommitSearch(){(0,a.m)({command:"search",state:{openPickInView:!0}})}showCommitActions(){null==this._context.commit||this._context.commit.isUncommitted||(0,r.$J)(this._context.commit)}async showFileActions(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.$J)(i,s)}switchMode(t){let e;if("wip"===t.mode){let{repoPath:i}=t;if(null==i){if(null==(e=this.container.git.getBestRepositoryOrFirst()))return;i=e.path}else e=this.container.git.getRepository(i)}this.setMode(t.mode,e)}async openFileComparisonWithWorking(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.ce)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileComparisonWithPrevious(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.vw)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)}),this.container.events.fire("file:selected",{uri:s.uri},{source:this.host.id})}async openFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;this.suspendLineTracker(),(0,r.ZB)(s,i,{preserveFocus:!0,preview:!0,...this.getShowOptions(t)})}async openFileOnRemote(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;(0,r.YM)(s,i)}async stageFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;await this.container.git.stageFile(i.repoPath,s.path)}async unstageFile(t){let e=await this.getFileCommitFromParams(t);if(null==e)return;let[i,s]=e;await this.container.git.unstageFile(i.repoPath,s.path)}getShowOptions(t){return t.showOptions}}X([(0,v.fF)({args:!1})],tt.prototype,"getState",1),X([(0,v.fF)({args:!1})],tt.prototype,"updateWipState",1),X([(0,v.fF)({args:!1})],tt.prototype,"updateRichState",1)}};